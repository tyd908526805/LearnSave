声明:指出存储类型,并给存储单元指定名称。声明不一定是定义(extern没有分配内存空间,只是告诉编译器变量在其他地方定义了)
定义:分配内存空间,还可以为变量指定初始值.(定义也是声明,定义变量的时候,同时给变量指出了存储类型,并给变量的存储单元指定了名称,所以也是声明）
一个变量的定义只有一个 声明可以有很多.


函数原型的返回值必须和函数定义相同.
函数原型的形参表的类型和顺序必须与函数定义相同(但是函数原型可以不写形参名称,写了形参名称也可以和原函数不一样)


sizeof和strlen的区别
1:
sizeof是操作符
strlen是库函数
2:
sizeof的参数可以是数据类型 变量
strlen只能是以'\0'结尾的字符串为参数
3:
编译器在编译时就计算出了sizeof的结果,sizeof计算的是数据类型占内存的大小.
strlen函数必须在运行时才能计算出来,计算的是字符串实际的长度.


C的static和C++的static区别
C中用来修饰局部静态变量和外部静态变量.
C++中用来定义类的成员变量(静态成员变量)和函数(静态函数).


new和malloc的区别
1:
new,delete是操作符.
malloc,free是库函数.
2:
new可以调用对象的构造函数.
delete可以调用对象的析构函数.
malloc仅分配内存,不执行构造函数.
free仅析构内存,不执行析构函数.
3:
new,delete返回的是某种数据类型指针.
malloc,free返回的是void指针.


指针可以是volatile吗?
可以,指针和变量一样,也有变化程序的不可控性


C++程序编译的内存分配情况
五大存储区:
    堆区,栈区,全局区,文字常量区,程序代码区.
静态存储区:
    内存在程序编译时就已经分配好,这块内存在程序整个运行期间都存在,速度快,不容易出错.
栈区:
    函数内部局部变量的存储单元都在栈上创建,函数执行结束时这些存储单元自动被释放,运算置于处理器的指令集中,效率高,但是分配的内存容量有限.
堆区:
    动态内存分配.由new,malloc申请任意大小内存,需要主动回收,不然会出现内存泄漏,频繁分配和释放不同大小的堆空间会产生堆内碎块.
    

strcpy,sprintf,memcpy的区别
操作对象不同:
    strcpy两个操作对象均为字符串.
    sprintf的操作源对象可以是多种数据类型,目的操作对象是字符串.
    memcpy的两个操作对象是任意可操作的内存地址,不限于何种数据类型.
执行效率不同:
    memcpy最高.
    strcpy次之.
    sprintf最差.
实现功能不同:
    strcpy主要实现字符串变量间的拷贝.
    sprintf主要实现其他数据类型格式到字符串的转化.
    memcpy内存块间的拷贝.
   
   
面向对象的三大特征
封装:
    封装可以隐藏实现细节，使得代码模块化.
继承:
    实现代码和数据的复用 三种类型private, protected, public.
多态:
    向不同的对象发送同一个消息,不同的对象接收回产生不同的行为.
    
    
拷贝构造函数和赋值运算符(=)
1:
    拷贝构造函数生成新的类对象
    赋值运算符不能
2:
    拷贝构造函数直接构造一个新的类对象,不用检验源对象和新建对象相同.
    赋值运算符需要检验源对象和新建对象类型(如果原来的对象中有内存分配需要先将内存释放).
    
    
重写,重载,隐藏的区别
重写和重载
    范围:
        重写和被重写的函数在两个类中
        重载和被重载的函数在一个类中
        隐藏函数和被隐藏函数不在同一个类中
    参数:
        被重写函数和重写函数的参数列表一定相同
        被重载函数和重载函数的参数列表一定不同
        隐藏函数和被隐藏函数的参数列表可以相同,可以不同,但是函数名要相同(参数不相同时,无论基类是否被virtual修饰,基类函数都会被隐藏,不会重写)
    virtual:
        重写的基类中被重写的函数必须有virtual修饰
        重载函数和被重载函数可以被virtual也可以没有

静态多态
    重载是静态绑定的多态,编译时完成
动态多态
    重写是动态绑定的多态,运行时完成
    
    
多态实现的原理
    在编译器发现一个类中有虚函数,便会为此类生成虚函数表vtable
    虚函数表的各表项为指向对应虚函数的指针.
    编译器还会再此类中插入一个指针vptr指向虚函数表.
    在类的构造函数中,编译器会隐含执行vptr与vtable的关联代码,将vptr指向对应的vtable,将类与此类的vtable联系起来
    在调用类的构造函数时,执行基础类的指针变成了指向具体的类的this指针,可以依靠此this指针得到正确的vtable.
    在有虚函数的类中,类最开始部分是一个虚函数表的指针,这个指针指向一个虚函数表,表中存放了虚函数的地址,实际的虚函数在代码段中.
    当子类继承父类的时候也会继承其虚函数表.
    当子类重写父类中虚函数的时候,会将其继承的虚函数表中的地址替换成重新写的函数地址.
    使用虚函数会增加内存开销,降低效率.
    虚函数表是每个对象实例共享的.
    虚函数指针是每个对象实例都有一个.
    
    
链表和数组的区别
    存储形式:
        数组:
            是一块连续的空间
            声明时确定长度
        链表:
            是一块不连续的动态空间
            长度可变
            每个结点保存相邻结点指针
    数据查找:
        数组:
            线性查找速度快
            查找操作直接使用偏移地址
        链表:
            链表需要按顺序检索节点
            效率低
    数据插入或删除:
        数组:
            需要大量数据移动
        链表:
            可以快速插入和删除节点
    越界问题:
        数组:
            存在越界问题
        链表:
            不存在越界问题
            
            
队列和栈的区别
    都是线性存储结构
    队列是先进先出
    栈是后进先出
    
    
typedef和define的区别
    用法不同:
        typedef:
            用来定义一种数据类型的别名
            增强程序的可读性
        define:
            主要用于定义常量或书写复杂使用频繁的宏
    执行时间不同:
        typedef:
            编译过程的一部分
            存在类型检查
        define:
            宏定义,预编译的部分,发生在编译之前
            只是简单的进行字符串的替换,不进行类型检查
    作用域不同:
        typedef:
            存在作用域限制
        define:
            不受作用域限制
    对指针操作不同:
        
        
const:
    定义一个只读的变量或对象
const 变量:
    限定变量不允许改变,提供程序安全性和可靠性
const 类型:
    这个类型的值为常量
const 修饰参数
    防止意外修改
const 修饰成员函数
    保护成员变量,不能修改成员变量
const对象只能访问const成员对象
非const的对象可以访问任何成员函数(包括const成员函数)
函数名,参数返回值都相同的const成员函数和非const成员函数可以构成重载
const成员函数可以访问所有成员变量,但是只能访问const的成员函数
非const成员函数可以访问任何成员,包括const成员函数
const成员函数不能修改任何的成员变量 除非变量用mutable修饰


static:
    定义的变量分配在静态存储区,默认值为0
    定义全局静态变量
    定义局部静态变量
    定义静态函数
    定义静态数据成员
    定义静态函数成员
    
    
extern:
    标识的变量或函数声明其定义在其他文件中,提示编译器遇到函数或变量到其他文件中寻找.
    
    
指针常量:
    定义了一个指针,这个指针的值只能在定义时初始化,其他地方不可改变
    强调指针的不可改变性
常量指针:
    定义了一个指针,这个指针指向一个只读的对象,不能通过常量指针改变这个对象的值
    强调了指针所指对象的不可改变性
    
    
如何避免野指针
    指针变量声明时没有初始化->指针声明时初始化
    指针p被delete或者free后面没有置为NULL->指针指向的内存空间被释放后指针指向NULL
    指针操作超越了变量的作用范围->在变量的作用域结束前释放指针并让指针指向NULL
    
    
常引用
    为了避免使用变量时,在不知情的情况下修改变量的值
    
    
构造函数能否是虚函数
    不能,也不能再构造函数中调用虚函数(执行的其实是父类的对应函数,自己没有构造完成)
析构函数能否是虚函数
    可以,也可以为纯虚函数(但是纯虚析构函数必须有定义体),因为析构函数的调用在子类中是隐含的
    当一个基类的指针删除了一个派生类的对象时,派生类的析构函数会被调用
    
    
深拷贝
    新建一个一模一样的对象
    不共享内存
    修改新对象也不会影响原对象
浅拷贝
    只复制指向某个对象的指针
    不复制对象本身,新建另一个对象
    对象复制了原对象的指针
    共用一个内存块
    
reinterpret_cast
    将一个指针转换成一个整数,也可以将整数转换成一个指针,或者不同类型的指针互相转换
const_cast
    常量转换
static_cast
    基本类型之间的转换
    void类型指针转换成任意基本类型指针
    有继承关系的父类和子类指针转换
dynamic_cast
    用于类继承层次间指针或引用的转换(主要用于向下的安全转换)
    RTTI(安全性体现)
        运行时的类型识别.程序能够使用基类的指针或引用来检查或引用所指对象的实际派生类型(判断指针原型)
        
        
tcp和udp区别
    tcp(流模式)
    优点
        可靠稳定
        有三次握手来建立连接
        数据传递时有确认,窗口,重传,拥塞控制机制
        在数据传完还会断开连接用来节约系统资源
        保证数据正确性和数据顺序
    缺点
        慢 效率低
        占用系统资源高
        传输数据前先建立链接 消耗时间
    upd(数据报模式)
    优点
        快 没有握手,确认,窗口,重传,拥塞控制机制
        无状态的传输协议
    缺点
        不可靠 不稳定
        容易发生丢包
        不保证数据顺序
    
进程和线程
    进程
        正在运行的程序实例
        操作系统分配资源的基本单位
        拥有自己的堆,栈,虚存空间,文件描述符等信息
        1.pid
        2.进程状态
        3.执行优先级
        4.上下文
        5.内存地址
    线程
        进程中真正执行任务的基本单位
        操作系统能进行运算调度的基本单位
        包含在进程中,进程中实际运行单位
一个运行的进程至少包含一个进程
一个进程至少包含一个线程
线程不能独立于进程而存在
    从属关系
        进程包含线程
    描述侧重点
        进程是分配资源的基本单位
        线程是操作系统调度的基本单位
    共享资源
        进程间资源不共享
        线程可以共享进程资源文件
    上下文切换速度
        线程切换很快(切换线程)
        进程切换慢
    操纵者
        进程操纵者是操作系统
        线程操纵者是编程人员
        
        
auto
    优点
        避免未初始化的变量
        避免冗长的变量声明
        具有直接闭包的能力
        类型捷径
    缺点
        不适用于不可见代理类
        类型推断
        
        
静态库和动态库
    静态链接
        在链接阶段,将汇编生成的目标文件.o与引用的库一起链接到可执行文件中
        编译期完成
        执行期间代码装载速度快
        使执行文件变大,浪费空间和资源
        需要全量更新
    动态链接
        运行时才被载入.
        不同的程序调用相同的库,内存中只需要有一份该共享库的实例
        避免浪费空间
        增量更新


C++的空类有哪些成员函数
为什么友元函数必须在类内部声明？
